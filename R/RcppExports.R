# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Section data according to breaks.
#'
#' Generates a vector of "section" values/levels according to differences in
#' the supplied vector. The function simply rolls over \code{x}, incrementing
#' the return vector every time there is a significant break in the pattern of
#' differences between adjacent elements of \code{x}. In practical terms, if
#' \code{x} is a series of timestamp values (see example), every time there is
#' a significant break in the timer (> 10 sec currently), the return vector is
#' incremented by 1.
#'
#' @param x a numeric vector (e.g. a timer column) that increments uniformly.
#'   When there is a \strong{significant} break in this uniformity, a new
#'   section is created, and so forth.
#'
#' @return a vector of the same shape as x.
#'
#' @examples
#' t_sec <- c(1:10, 40:60, 100:150)       # Discontinuous timer values.
#' pwr   <- runif(length(t_sec), 0, 400)  # Some power values.
#' x     <- data.frame(t_sec, pwr)
#' # Generate section levels.
#' x$section <- diff_section(x$t_sec)
#' print(x)
#'
#' @export
diff_section <- function(x) {
    .Call('cycleRtools_diff_section', PACKAGE = 'cycleRtools', x)
}

#' Efficient maximal mean values.
#'
#' A more efficient implementation of \code{\link{mmv}}. Simply takes a vector
#' (\code{x}) of values and rolls over them element wise by defined windows.
#' Returns a vector of maximum mean values for each window size.
#'
#' @param x a numeric vector of values.
#' @param windows window size(s) (in element units) for which to
#'   generate maximum mean values.
#'
#' @return a vector of \code{length(windows)}.
#'
#' @export
mmv2 <- function(x, windows) {
    .Call('cycleRtools_mmv2', PACKAGE = 'cycleRtools', x, windows)
}

rollmean_ <- function(x, window) {
    .Call('cycleRtools_rollmean_', PACKAGE = 'cycleRtools', x, window)
}

rollmean_ema_ <- function(x, window, wt) {
    .Call('cycleRtools_rollmean_ema_', PACKAGE = 'cycleRtools', x, window, wt)
}

Wbal_ <- function(t, P, CP) {
    .Call('cycleRtools_Wbal_', PACKAGE = 'cycleRtools', t, P, CP)
}

zone_index_ <- function(x, zb) {
    .Call('cycleRtools_zone_index_', PACKAGE = 'cycleRtools', x, zb)
}

